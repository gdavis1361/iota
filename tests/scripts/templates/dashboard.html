<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IOTA Performance Monitor</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.css" rel="stylesheet">
    <meta name="csrf-token" content="{{ csrf_token }}">
    <style>
        .metric-card {
            transition: all 0.3s ease;
        }
        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .alert-history {
            max-height: 400px;
            overflow-y: auto;
        }
        .navbar-user {
            color: #fff;
            margin-right: 15px;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">IOTA Monitor</a>
            <div class="navbar-nav me-auto">
                <a class="nav-link active" href="#metrics">Metrics</a>
                <a class="nav-link" href="#alerts">Alerts</a>
                <a class="nav-link" href="#config">Configuration</a>
            </div>
            <div class="d-flex">
                <span class="navbar-user">{{ session.username }}</span>
                <a href="{{ url_for('logout') }}" class="btn btn-outline-light btn-sm">Logout</a>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        <!-- Metrics Overview -->
        <section id="metrics" class="mb-5">
            <h2>System Metrics</h2>
            <div class="row" id="metric-cards">
                <!-- Dynamically populated -->
            </div>
            <div class="card mt-4">
                <div class="card-body">
                    <canvas id="metricsChart"></canvas>
                </div>
            </div>
        </section>

        <!-- Alert History -->
        <section id="alerts" class="mb-5">
            <h2>Alert History</h2>
            <div class="card">
                <div class="card-body alert-history" id="alertList">
                    <!-- Dynamically populated -->
                </div>
            </div>
        </section>

        <!-- Configuration -->
        <section id="config" class="mb-5">
            <h2>Notification Configuration</h2>
            <div class="card">
                <div class="card-body">
                    <form id="configForm">
                        <!-- Dynamically populated -->
                    </form>
                </div>
            </div>
        </section>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <script>
        // CSRF token handling
        const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

        // Add CSRF token to all fetch requests
        function fetchWithCSRF(url, options = {}) {
            options.headers = {
                ...options.headers,
                'X-CSRF-Token': csrfToken
            };
            return fetch(url, options);
        }

        // Error handling
        function handleError(error) {
            console.error('Error:', error);
            alert('An error occurred. Please check the console for details.');
        }

        // Fetch and display metrics
        async function updateMetrics() {
            try {
                const response = await fetchWithCSRF('/api/metrics/recent');
                if (!response.ok) throw new Error('Failed to fetch metrics');
                const metrics = await response.json();

                // Update metric cards
                const cards = document.getElementById('metric-cards');
                cards.innerHTML = ''; // Clear existing

                const latestMetrics = metrics[metrics.length - 1] || {};
                for (const [key, value] of Object.entries(latestMetrics)) {
                    cards.innerHTML += `
                        <div class="col-md-3 mb-4">
                            <div class="card metric-card">
                                <div class="card-body">
                                    <h5 class="card-title">${key}</h5>
                                    <h3 class="card-text">${value}</h3>
                                </div>
                            </div>
                        </div>
                    `;
                }

                // Update chart
                updateChart(metrics);
            } catch (error) {
                handleError(error);
            }
        }

        // Fetch and display alerts
        async function updateAlerts() {
            try {
                const response = await fetchWithCSRF('/api/alerts/recent');
                if (!response.ok) throw new Error('Failed to fetch alerts');
                const alerts = await response.json();

                const alertList = document.getElementById('alertList');
                alertList.innerHTML = ''; // Clear existing

                alerts.forEach(alert => {
                    alertList.innerHTML += `
                        <div class="alert alert-${alert.level.toLowerCase()} mb-2">
                            <strong>${alert.metric}:</strong> ${alert.message}
                            <small class="float-end">${new Date(alert.timestamp).toLocaleString()}</small>
                        </div>
                    `;
                });
            } catch (error) {
                handleError(error);
            }
        }

        // Load and display configuration
        async function loadConfig() {
            try {
                const response = await fetchWithCSRF('/api/config');
                if (!response.ok) throw new Error('Failed to fetch configuration');
                const config = await response.json();

                const form = document.getElementById('configForm');
                form.innerHTML = ''; // Clear existing

                // Create form fields for each config section
                for (const [method, settings] of Object.entries(config.methods)) {
                    form.innerHTML += `
                        <div class="mb-4">
                            <h4>${method}</h4>
                            <div class="form-check mb-2">
                                <input class="form-check-input" type="checkbox" id="${method}-enabled"
                                       ${settings.enabled ? 'checked' : ''}>
                                <label class="form-check-label" for="${method}-enabled">
                                    Enable ${method} notifications
                                </label>
                            </div>
                            ${Object.entries(settings)
                                .filter(([key]) => key !== 'enabled')
                                .map(([key, value]) => `
                                    <div class="mb-2">
                                        <label class="form-label" for="${method}-${key}">${key}</label>
                                        <input type="text" class="form-control" id="${method}-${key}"
                                               value="${value}">
                                    </div>
                                `).join('')}
                        </div>
                    `;
                }

                // Add save button
                form.innerHTML += `
                    <button type="submit" class="btn btn-primary">Save Configuration</button>
                `;
            } catch (error) {
                handleError(error);
            }
        }

        // Initialize chart
        let metricsChart;
        function updateChart(metrics) {
            const ctx = document.getElementById('metricsChart').getContext('2d');

            if (metricsChart) {
                metricsChart.destroy();
            }

            const labels = metrics.map(m => new Date(m.timestamp).toLocaleTimeString());
            const datasets = Object.keys(metrics[0] || {}).map(key => ({
                label: key,
                data: metrics.map(m => m[key]),
                fill: false,
                tension: 0.1
            }));

            metricsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Save configuration
        document.getElementById('configForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            try {
                const config = {
                    methods: {}
                };

                // Gather form data
                const form = e.target;
                for (const method of Object.keys(currentConfig.methods)) {
                    config.methods[method] = {
                        enabled: form.querySelector(`#${method}-enabled`).checked
                    };

                    // Add other settings
                    for (const [key, value] of Object.entries(currentConfig.methods[method])) {
                        if (key !== 'enabled') {
                            config.methods[method][key] = form.querySelector(`#${method}-${key}`).value;
                        }
                    }
                }

                // Save configuration
                const response = await fetchWithCSRF('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(config)
                });

                if (!response.ok) throw new Error('Failed to save configuration');

                alert('Configuration saved successfully');
            } catch (error) {
                handleError(error);
            }
        });

        // Update data periodically
        setInterval(updateMetrics, 5000);
        setInterval(updateAlerts, 5000);

        // Initial load
        updateMetrics();
        updateAlerts();
        loadConfig();
    </script>
</body>
</html>
